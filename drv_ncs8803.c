#include "hal_soft_i2c.h"
#include "drv_ncs8803.h"
#include "drv_log.h"
#include "hal_delay.h"
void Ncs8803_Init(void)
{
    I2cInit(HAL_I2C1, PB10, PB11);
}

void Ncs8803_1920_1080_Write_For_Common(void) //这里故意写了不亮屏的寄存器，目的是为了读0x18，等0想8读到100次稳定之后再写可以亮屏的寄存器。
{
    //SHEET6
    uint8_t write_addr [] = {0xa3,	0x5d,	0x5e,	0xa3,	0xeb,	0xed,	0x0f,	0x0,	0x1,	0x2,	0x7,	0x9,	0x0b,	0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,	0x18,	0x19,	0x1a,	0x1b,	0x1c,	0x1d,	0x1e,	0x1f,	0x60,	0x70,	0x71,	0x73,	0x74,	0x0,	0x1,	0x2,	0x0b,	0x0e,	0x0f,	0x11,	0x2c,	0x2d,	0x84,	0x85,	0x0,	0x0f,	0x2b,	0x2e,	0x2f,	0x30,	0x31,	0x35,	0x34,	0x34,	0x36,	0x2f,	0x30,	0x31,	0x35,	0x34,	0x34,	0x36};
    uint8_t write_dev  [] = {0xe0,	0xea,	0xea,	0xe0,	0xea,	0xea,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xe0,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea};
    uint8_t write_bytes[] = {0x10,	0x10,	0x0d,	0x11,	0x0,	0x0,	0x1,	0x5,	0x0,	0x5,	0xc2,	0x1,	0x0,	0x8,	0x20,	0x0,	0x70,	0x7,	0x80,	0x4,	0x57,	0x0,	0x1c,	0x4,	0x38,	0x0,	0x20,	0x0,	0x5,	0x0,	0x0,	0x1,	0x0,	0x20,	0xb0,	0x0,	0x5c,	0x47,	0x6,	0x6,	0x88,	0x4,	0x40,	0x10,	0x32,	0xb1,	0x0,	0x7,	0xff,	0xf7,	0xff,	0xff,	0x80,	0x0,	0x40,	0x3,	0xf7,	0xff,	0xff,	0x80,	0x0,	0x40,	0x3};//13.3
    for(int i = 0; i < 63; i++)
    {
        I2cDeviceWriteBytes(0, write_dev[i], write_addr[i], 1, &write_bytes[i], 1);
        DelayMs(2);
    }
}

void Ncs8803_1920_1080_Write(void)
{
    //SHEET3
    uint8_t write_addr [] = {0xa3,	0x5d,	0x5e,	0xa3,	0xeb,	0xed,	0x0f,	0x0,	0x1,	0x2,	0x7,	0x9,	0x0b,	0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,	0x18,	0x19,	0x1a,	0x1b,	0x1c,	0x1d,	0x1e,	0x1f,	0x60,	0x70,	0x71,	0x73,	0x74,	0x7e,	0x78,	0x79,	0x7a,	0x7b,	0x7c,	0x7d,	0x0,	0x1,	0x2,	0x0b,	0x0e,	0x0f,	0x11,	0x2c,	0x2d,	0x84,	0x85,	0x0,	0x0f,	0x2b,	0x2e,	0x2f,	0x30,	0x31,	0x35,	0x34,	0x34,	0x36};
    uint8_t write_dev  [] = {0xe0,	0xea,	0xea,	0xe0,	0xea,	0xea,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xe0,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xe0,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea,	0xea};
    uint8_t write_bytes[] = {0x10,	0x10,	0x0d,	0x11,	0x0,	0x0,	0x1,	0x5,	0x0,	0x5,	0xc2,	0x1,	0x0,	0x8,	0x20,	0x0,	0x70,	0x7,	0x80,	0x4,	0x57,	0x0,	0x1c,	0x4,	0x38,	0x0,	0x20,	0x0,	0x5,	0x0,	0x0,	0x0,	0x0,	0x20,	0x1,	0x0,	0x46,	0x28,	0x0,	0x80,	0x0,	0xb0,	0x0,	0x5c,	0x47,	0x10,	0x10,	0xaa,	0x4,	0x40,	0x1,	0x32,	0xb1,	0x0,	0x7,	0xff,	0xf7,	0xff,	0xff,	0x80,	0x0,	0x40,	0x3};//13.3
    for(int i = 0; i < 63; i++)
    {
        I2cDeviceWriteBytes(0, write_dev[i], write_addr[i], 1, &write_bytes[i], 1);
        DelayMs(2);
    }
}

static uint8_t* Ncs8803_1920_1080_Read(void)
{
    static uint8_t read_bytes[63] = {0};
    uint8_t read_addr [] =  {0Xa3,0X5d,0X5e,0Xa3,0Xeb,0Xed,0X0f,0X00,0X01,0X02,0X07,0X09,0X0b,0X10,0X11,0X12,0X13,0X14,0X15,0X16,0X17,0X18,0X19,0X1a,0X1b,0X1c,0X1d,0X1e,0X1f,0X60,0X70,0X71,0X73,0X74,0X7e,0X78,0X79,0X7a,0X7b,0X7c,0X7d,0X00,0X01,0X02,0X0b,0X0e,0X0f,0X11,0X2c,0X2d,0X84,0X85,0X00,0X0f,0X2b,0X2e,0X2f,0X30,0X31,0X35,0X34,0X34,0X36};
    uint8_t read_dev  [] =  {0Xe0,0Xea,0Xea,0Xe0,0Xea,0Xea,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xe0,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xe0,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea,0Xea};
    for(int i = 0; i < 63; i++)
    {
        I2cDeviceReadBytes(0, read_dev[i], read_addr[i], 1, &read_bytes[i], 1);
        DelayMs(2);
        LOG("dev:0x%02x = 0x%02x", read_addr[i], read_bytes[i]);
    }
    return read_bytes;
}

bool Hdmi_Det()//查看hdmi信号是否联通，若联通为true。
{
    uint8_t rev_data [2] = {0x00, 0x00};
    uint8_t send_data[2] = {0xB0, 0xB1};

    I2cDeviceReadBytes(0, 0xEA, 0xE2, 1, &rev_data[0], 1);
    I2cDeviceReadBytes(0, 0xEA, 0xE4, 1, &rev_data[1], 1); // 读取75寄存器E4的值
    if((rev_data[0] != rev_data[1]) ||  rev_data[0] != 0x18)//不同屏参设定读出的E4值会有出入，请参加正常显示读出的值做判断依据
    {
        I2cDeviceWriteBytes(0, 0xEA, 0x00, 1, &send_data[0], 1);
        I2cDeviceWriteBytes(0, 0xEA, 0x00, 1, &send_data[1], 1);
    }
    LOG("e2 = 0x%02x ,e4 = 0x%02x", rev_data[0], rev_data[1]);
    if((rev_data[0] == rev_data[1]) && (rev_data[1] == 0x18))
    {
        return true;
    } else {
        return false;
    }
}


void LcdInit(bool *lcd_write_allow_state)//传参为允许写芯片的标志位
{
    Ncs8803_1920_1080_Write_For_Common();
    *lcd_write_allow_state = true;
}

void Ncs8803Check(bool *hdmi_ok, bool *hdmi_begin) //请循环调用 当检测到hdmi失败多次时 置传参为false 成功同理
{
    static int i_add_hdmi_fail = 0;
    static int i_add_hdmi_success = 0;
    static int hdmi_success_begin = 0;
    if (!*hdmi_begin){
        hdmi_success_begin = 0;
        *hdmi_begin = true;
    }

    if(Hdmi_Det()) {
        i_add_hdmi_success++;
        i_add_hdmi_fail = 0;
    } else {
        i_add_hdmi_fail++;
        i_add_hdmi_success = 0;
    }

    if(i_add_hdmi_success > 50 && !hdmi_success_begin) {
        *hdmi_ok = false;
        i_add_hdmi_success = 0;
        hdmi_success_begin = 1;
        //LOG("信号稳定，开始计数标志位为%d",hdmi_success_begin);
    }

    if(i_add_hdmi_success > 0 && hdmi_success_begin) {
        //LOG("计数到%d，开始点屏",i_add_hdmi_success);
        *hdmi_ok = true;
    }

    if(i_add_hdmi_fail > 100) {
        *hdmi_ok = false;
        //LOG("信号不稳定，开始计数标志位为%d",hdmi_success_begin);
    }

    if(i_add_hdmi_success > 10000) {//防止溢出
        i_add_hdmi_success = 100;
    }

    if(i_add_hdmi_fail > 10000) {//防止溢出
        i_add_hdmi_fail = 100;
    }

    //LOG("i_add_hdmi_success = %d",i_add_hdmi_success);
    //LOG("i_add_hdmi_fail = %d",i_add_hdmi_fail);
    //LOG("hdmi_ok = %d",*hdmi_ok);
}
